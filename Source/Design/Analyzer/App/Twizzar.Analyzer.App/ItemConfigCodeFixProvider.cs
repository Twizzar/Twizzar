using System.Collections.Immutable;
using System.Composition;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeActions;
using Microsoft.CodeAnalysis.CodeFixes;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Twizzar.Analyzer.Core
{
    /// <summary>
    /// Does not work at the moment.
    /// Provides code fixes for item config diagnostics generated by ItemConfigPathSourceGenerator.
    /// </summary>
    [ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(ItemConfigCodeFixProvider))]
    [Shared]
    public class ItemConfigCodeFixProvider : CodeFixProvider
    {
        #region properties

        /// <inheritdoc />
        public override ImmutableArray<string> FixableDiagnosticIds { get; } =
            ImmutableArray<string>.Empty.Add("Vi0002");

        /// <inheritdoc />
        public sealed override FixAllProvider GetFixAllProvider()
        {
            // See https://github.com/dotnet/roslyn/blob/main/docs/analyzers/FixAllProvider.md for more information on Fix All Providers
            return WellKnownFixAllProviders.BatchFixer;
        }

        #endregion

        #region members

        /// <inheritdoc />
        public override async Task RegisterCodeFixesAsync(CodeFixContext context)
        {
            var diagnostic = context.Diagnostics.First();
            var diagnosticSpan = diagnostic.Location.SourceSpan;

            var tree = await context.Document.GetSyntaxTreeAsync();

            if (tree == null)
            {
                return;
            }

            var root = await tree.GetRootAsync();
            var classNode = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<ClassDeclarationSyntax>().FirstOrDefault();

            if (classNode != null)
            {
                context.RegisterCodeFix(
                    CodeAction.Create(
                        title: "Make class partial.",
                        createChangedDocument: c => MakePartialAsync(context.Document, classNode, c),
                        equivalenceKey: "partial-" + classNode.Identifier.Value),
                    diagnostic);
            }
        }

        private static async Task<Document> MakePartialAsync(
            Document document,
            ClassDeclarationSyntax classNode,
            CancellationToken cancellationToken)
        {
            var newClassNode = classNode.AddModifiers(Token(SyntaxKind.PartialKeyword));

            var newRoot =
                (await classNode.SyntaxTree.GetRootAsync(cancellationToken)).ReplaceNode(classNode, newClassNode);

            return document.WithSyntaxRoot(newRoot);
        }

        #endregion
    }
}